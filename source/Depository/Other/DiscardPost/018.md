---
title: 监督学习算法：决策树及决策树集成
date: 2019-10-18 14:22:09
tags: supervised learning algorithm
categories: machine learning
description: 本文简单介绍监督学习的决策数模型以及决策树集成中的随机森林模型和梯度提升回归树模型
cover: /Depository/Img/Post/0019.png
top_img: /Depository/Img/Post/0013.jpg
---

**<center>决策树及决策树集成</center>**

决策树是广泛用于分类和回归任务的模型。本质上，它是一层层的if/else问题中进行学习，并得出结论

**集成**是合并多个机器学习模型来构建更强大模型的方法。在机器学习文献中有许多模型都属于这一类，但已证明有两种集成模型对大量分类和回归的数据集都是有效的，二者都以决策树为基础，分别是：**[随机森林](#01)**和**[梯度提升回归树](#02)**

---

### 决策树

决策树是广泛用于分类和回归任务的模型。本质上，它是一层层的if/else问题中进行学习，并得出结论

* 决策树中每个结点代表一个问题或包含答案的终结点(也叫叶结点)，如果树中某个叶结点所包含的数据点的目标值都相同，那么这个叶结点是纯的

* 防止决策树过拟合有两种常见策略：一种是及早停止树的生长，也叫预剪枝；另一种是先构造树，但随后删除或折叠信息量很少的结点，也叫后剪枝(或剪枝)

*预剪枝的限制条件可能包括限制树的最大深度，限制叶结点的最大数目，或者规定一个结点中数据点的最小数目来防止继续划分*

**scikit-learn的决策树在DecisionTreeRegressor和DecisionTreeClassifier类中实现**

*scikit-learn只实现了预剪枝，没有实现后剪枝*

`from sklearn.tree import DecisionTreeClassifier DecisionTreeRegressor`

#### DecisionTreeClassifier

`from sklearn.tree import DecisionTreeClassifier`

**方法**

* fit方法：用数据训练模型
* predict方法：对数据用模型进行预测
* score方法：调用该方法评估模型精度(参数为训练集时表示训练精度，参数为测试集时表示泛化精度)
* export_graphviz函数：tree模块的export_graphviz函数，用来可视化树，这个函数会生成一个.dot文件

*可利用graphviz模块读取这个.dot文件并可视化(也可用任意读取.dot文件的程序)*

* feayure_impoetances_方法：树的特征重要性，该方法为每个特征对树的决策的重要性进行排序，对于每个特征来说都介于0和1之间，0表示根本没有用到，1表示完美预测目标值。特征重要性的求和始终为1

**参数**

* random_state：随机生成器种子，用于重现结果
* max_depth：max_depth表示树的深度
* max_leaf_nodes：max_leaf_nodes表示限制树的叶结点的最大数目
* min_samples_leaf：min_samples_leaf表示规定一个叶结点数据点的最小数目

**示例**

```python
from sklearn.tree import DecisionTreeClassifier
from sklearn.model_selection import train_test_split
from sklearn.datasets import load_breast_cancer
----------
#用scikit-learn中的load_breast_cancer函数来加载威斯康星州乳腺癌数据集(cancer)
cancer = load_breast_cancer()
#用sklearn.model_selection中的train_test_split来拆分数据
X_train, X_test, y_train, y_test = train_test_split(cancer.data, cancer.target, stratify=cancer.target, random_state=42)
----------
tree = DecisionTreeClassifier(random_state=0)
#设置random_state参数为0来内部解决平局问题
tree.fit(X_train, y_train)
#用数据训练tree模型
tree.score(X_train, y_train)
#计算模型训练精度，计算得出精度为1.000
tree.score(X_test, y_test)
#计算模型泛化精度，计算得出精度为0.937
#训练精度为100%，但泛化精度只有93.7%，表明可能存在过拟合
----------
tree = DecisionTreeClassifier(max_depth=4, random_state=0)
#设置max_depth=4，即设置树最大深度为4,防止过拟合
tree.fit(X_train, y_train)
tree.score(X_train, y_train)
#计算模型训练精度，计算得出精度为0.988
tree.score(X_test, y_test)
#计算模型泛化精度，计算得出精度为0.951
#通过设置max_depth虽然降低了训练精度，但是有效提高了泛化精度
----------
#利用tree中的export_graphviz函数来可视化树(该函数会生成一个.dot文件)
from sklearn.tree import export_graphviz
export_graphviz(tree, out_file='tree.dot', class_name=["malignant", "benign"], feature_name=cancer.feature_name, impurity=False, filled=Trye)
#利用graphviz模块读取.dot文件并将其可视化(可以使用任意能够读取.dot文件的程序)
import graphviz
with open("tree.dot") as f:
    dot_graph = f.read()
graphviz.Source(dot_graph)
#可视化图中每个结点的samples给出了该结点中的样本个数
#可视化图中每个结点的values给出的是每个类别的样本个数
#可视化图中每个结点的class给出的是到该结点的类别
----------
tree.feature_importances_
#特征重要性，内容为0至1的数，特征重要性的求和始终为1
```

#### DecisionTreeRegressor

`from sklearn.tree import DecisionTreeRegressor`

*对于用于回归的决策树，所有内容都和用于分类的决策树相似*

*DecisionTreeRegressor(以及其它基于树的回归模型)不能外推，也不能在训练数据范围之外进行预测*

#### 决策树优缺点

* 优点：一是得到的模型很容易可视化，非专家也很容易理解(至少对于较小的树而言)；二是算法完全不受数据缩放的影响(因为每个特征被单独处理，而且数据的划分也不依赖于缩放，因此决策树算法不需要特征预处理，比如归一化或标准化)。特别是特征的尺度完全不一样时或者二元特征和连续特征同时存在时，决策树效果很好

* 缺点：即使做了预剪枝，决策树也经常过拟合，泛化性能很差(大叔多应用中都用决策树集成来替代单棵决策树)

---

<span id="01"> </span>

### 随机森林

随机森林本质上是多个决策树的集合，其中每棵树都和其他树略有不同，可以有效防止过拟合


*1.随机森林背后的思想是，每棵树的预测可能都相对比较好，但可能对部分数据过拟合；如果构造很多树，并且每棵树的预测都很好，但都以不同的方式过拟合，那么可以对这些树的结果取平均值来降低过拟合(既能减少过拟合又能保持树的预测能力，这可以在数学上严格证明)*

*2.构造随机森林时，首先确定构造树的棵数(n_estimators参数)，然后构造每一棵树时首先对数据进行自助采样(从n_samples个数据点中有放回地重复随机抽取一个样本，共抽取n_samples次。这样会创建一个与原数据集大小相同的数据集)*

*3.用随机森林进行预测时，算法首先对森林中的每棵树进行预测。对于回归问题，对所有树的结果取平均值作为最终预测值；对于分类问题，则用软投票策略(每个算法作出软预测，给出每个可能的输出标签的概率，然后对所有树的预测概率取平均值，最后将概率最大的的类别作为预测结果)*

**RandomForestRegressor/RandomForestClassifier**

* 随机森林分类模型：from sklearn.ensemble import RandomForestClassifier
* 随机森林回归模型：from sklearn.ensemble import RandomForestRegressor

**方法**

* fit方法：用数据训练模型
* predict方法：对数据用模型进行预测
* score方法：调用该方法评估模型精度(参数为训练集时表示训练精度，参数为测试集时表示泛化精度)

**参数**

* n_estimators参数：确定构造树的棵树
* max_features参数：随机森林算法选择特征子集时子集的特征个数
* random_state参数：随机生成器种子，用于确定随机状态(因为森及森林本质上是随机的)(可以不设置该参数，重现结果时需要固定该参数)
* max_depth参数：max_depth表示限制树的最大深度
* max_leaf_nodes：max_leaf_nodes表示限制树的叶结点的最大数目
* min_samples_leaf：min_samples_leaf表示规定一个叶结点数据点的最小数目
* n_jobs参数：n_jobs参数调节使用的CPU内核个数，设置参数值大于内核数没有意义，设置参数值为-1则表示启用所有内核

*1.max_features参数较大，那么随机森林中的树都很相似，利用最独特的特征可以轻松拟合数据；如果max_features参数较小，那么随机森林中的树将会差异很大，为了很好地拟合数据，每棵树的深度都要很大*

*2.一般情况，对于分类默认max_features=sqrt(n_features)，对于回归默认max_features=n_features；增大max_features或max_leaf_nodes有时也可以提高性能，还可以大大降低用于训练和预测的时间和空间要求*

**属性**

* estimator_属性：estimator_属性保存随机森林中的树

*随机森林也可以给出特征重要性，计算方法是将随机森林中所有树的特征重要性求和并取平均，一般来说随机森林给出的特征重要性要比单棵树给出的更为可靠*

**示例**

```python
from sklearn.ensemble import RandomForestClassifier
from sklearn.datasets import make_moons
#使用5棵树的随机森林应用到two_moons数据集
X， y = make_moons(n_samples=100, noise=0.25, random_state=3)
X_train, X_test, y_train, y_test = train_test_split(X, y, stratify=y, random_state=42)
forest = RandomForestClassifier(n_estimators=5, random_state=2)
forest.fit(X_train, y_train)
#随机森林中的树保存在estimator_属性中
----------
#将包含100课树的随机森林应用在乳腺癌数据集上
X_train, X_test, y_train, y_test = train_test_split(cancer.data, cancer.target, random_state=0)
forest.fit(X_train, y_train)
forest.score(X_train, y_train)
forest.score(X_test, y_test)
#训练精度为1.000,泛化精度为0.972；在没有任何调节下，随机森林的精度为97%，比线性模型或单棵决策树都要好
#可用通过调节max_features参数或预剪枝，但是随机森林的默认参数通常可以给出很好的结果
```

#### 随机森林优缺点

* 优点：随机森林拥有决策树的所有优点，还弥补了一些缺点
* 缺点：对于维度非常高的稀疏数据(比如文本数据),随机森林表现不是很好；训练和预测速度都慢于线性模型；不便于向非专家解释模型

---

<span id="02"> </span>

### 梯度提升回归树

梯度提升回归树通过合并多个决策树来构建一个更为强大的模型(虽然名字中含有回归，但该模型既可用于回归也可用于分类)

*1.如果想要将梯度提升应用在大规模问题上，可以研究一下xgboost包及其python接口，该库目前在许多数据集上的速度都比scikit-learn对梯度提升的实现要快(有时调参也更简单)*

*2.与随机森林不同，梯度提升采用连续的方式构造树，每棵树都试图纠正前一棵树的错误(默认情况下，梯度提升回归树中没有随机化，而是用到了强预剪枝)；梯度提升树通常使用深度很小(1到5之间)的树，这样模型占用内存更少，预测速度也很快*

**GradientBoostingClassifier**

`from sklearn.ensemble import GradientBoostingClassifier`

**方法**

* fit方法：用数据训练模型
* predict方法：对数据用模型进行预测
* score方法：调用该方法评估模型精度(参数为训练集时表示训练精度，参数为测试集时表示泛化精度)

**参数**

* learning_rate参数：学习率，用于控制每棵树对前一棵树的错误的纠正强度
* n_estimators参数：迭代的树的数量
* max_depth参数：max_depth表示限制树的最大深度
* max_leaf_nodes：max_leaf_nodes表示限制树的叶结点的最大数目
* min_samples_leaf：min_samples_leaf表示规定一个叶结点数据点的最小数目

*1.n_estimators与learning_rate参数高度相关，因为learning_rate越低，就需要更多的树来构造具有相似复杂度的模型*

*2.随机森林中n_estimators值总是越大越好，但是梯度提升不同，增大n_estimators会导致模型更加复杂，进而可能导致过拟合(通常做法是根据时间和内存的预算选择合适的n_estimators，然后对不同的learning_rate进行遍历)*

*3.通常梯度提升模型的max_depth参数都设置得很小，一般不会超过5*

**示例**

```python
from sklearn.ensemble import GradientBoostingClassifier
X_train, X_test, y_train, y_test = train_test_split(cancer.data, cancer.target, random_state=0)
#在乳腺癌数据集上应用GradientBoostingClassifier模型，默认使用100棵树，最大深度是3,学习率为0.1
gbrt = GradientBoostingClassifier(random_state=0)
gbrt.fit(X_train, y_train)
gbrt.score(X_train, y_train)
gbrt.score(X_test, y_test)
#训练精度为1.000,泛化精度为0.958
#由于训练精度达到100%。所以很可能存在过拟合(为了降低过拟合，我们可以限制最大深度来加强预剪枝，也可降低学习率)
----------
#限制最大深度为1来加强预剪枝
gbrt = GradientBoostingClassifier(random_state=0, max_depth=1)
gbrt.fit(X_train, y_train)
gbrt.score(X_train, y_train)
gbrt.score(X_test, y_test)
#训练精度为0.991,泛化精度为0.972
----------
#降低学习率为0.01
gbrt = GradientBoostingClassifier(random_state=0, learning_rate=0.01)
gbrt.fit(X_train, y_train)
gbrt.score(X_train, y_train)
gbrt.score(X_test, y_test)
#训练精度为0.988,泛化精度为0.965
```

**优缺点**

* 优点：梯度提升回归树是监督学习中最强大也最常用的模型之一；不需要对数据进行缩放就可以表现得很好；也适用于二元特征与连续特征同时存在的数据集
* 缺点：需要仔细调参，而且训练时间可能会比较长；与其它基于树的模型一样，通常不适用于高维稀疏数据

---