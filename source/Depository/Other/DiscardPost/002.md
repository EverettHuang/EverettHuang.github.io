---
title: NumPy数组
date: 2019-10-12 18:45:21
tags: NumPy
categories: Data analysis
description: NumPy是python数值计算最重要的基础包
cover: /Depository/Img/Post/0005.png
top_img: /Depository/Img/Post/0001.png
---


**<center>NumPy数组基础</center>**

---

```python
import numpy as np
```

---

### NumPy数组基础知识

NumPy最重要的一个特点就是其N维数组对象(**ndarray**)

1. 对ndarray数组执行数学运算语法和标量元素之间的运算一致
2. ndarray为一个同构数据多维容器(其中所有元素必须为相同类型)
3. 每一个ndarray都有一个shape(表示各维度大小的元组)和一个dtype(用于说明ndarray数组数据类型的对象)

---

#### 创建ndarray

##### array函数

使用NumPy的array函数(np.array)创建ndarray数组

* array函数接受一切序列型的对象(包括其他ndarray数组)
* 除非指定ndarray数组类型，否则array会为新的ndarray数组推断一个较为合适的数据类型(保存在dtype中)

---

##### 其他函数

1. zeros函数：可以创建指定长度或形状的全0数组，参数为表示长度或形状的元组
2. ones函数：可以创建指定长度或形状的全1数组，参数为表示长度或形状的元组
3. empty函数：可以创建指定长度或形状的没有任何具体数值的数组(数组内为垃圾值)，参数为表示长度或形状的元组
4. arange函数：arange函数为python内置函数range的数组版

*表：相关函数*

函数 | 说明
:-: | :-:
array | 将输入数据(列表,元组,数组或其他序列类型)转换为ndarray。要么推断出dtype，要么特别指定dtype。，默认直接复制输入数据
asarray | 将输入转换为ndarray，如果本身是一个ndarray就不进行复制
arange | 类似于内置的range，但返回的是一个ndarray而不是列表
ones, ones_like | 根据指定的形状和dtype创建一个全1数组。one_like以另一个数组为参数，并根据其形状和dtype创建一个全1数组
zeros, zeros_like | 类似于ones,ones_like。只不过产生的是全0数组
empty, empty_like | 创建新数组，只分配内存但不填充任何值
full,full_like | 用fill value中的所有值，根据指定的形状和dtype创建一个数组。full_like使用另一个数组，用相同的形状和dtype创建
eye, identity | 创建一个正方的N x N单位矩阵(对角线为1,其余为0)

* 由于NumPy关注数值计算，所以没有特别指定的话，数据类型基本都是float64(浮点数)

---

#### ndarray数据类型

ndarray的数据类型储存在**dtype**中，dtype是一个特殊的对象，它含有ndarray将一块内存解释为特定数据类型所需的信息

*表：NumPy的数据类型*

类型 | 类型代码 | 说明
:-: | :-: | :-:
int8, uint8 | i1, u1 | 有符号和无符号的8位(1个字节)整型
int16, uint16 | i2, u2 | 有符号和无符号的16位(2个字节)整型
int32, uint32 | i4, u4 | 有符号和无符号的32位(4个字节)整型
int64, uint64 | i8, u8 | 有符号和无符号的64位(8个字节)整型
float16 | f2 | 半精度浮点数
float32 | f4或f | 标准的单精度浮点数。与C的float兼容
float64 | f8或d | 标准的双精度浮点数。与C的double和Python的float对象兼容
float128 | f16或g | 扩展精度浮点数
complex64, complex128, complex256 | c8, c16, c32 | 分别用两个32位, 64位和128位浮点数表示的复数
bool | ? | 存储True和False值的布尔类型
object | O | Python对象类型
string_ | S | 固定长度的字符串类型(每个字符1个字节)。例如，要创建一个长度为10的字符串，应使用S10
unicode_ | U | 固定长度的unicode类型(字节数由平台决定)。跟字符串的定义方式一样(如U10)

##### astype方法

可使用ndarray的astype方法明确地将一个数组从一个dtype转换为另一个dtype

*调用astype总会创建一个新的数组(一个数据的备份)，即使新的dtype与旧的dtype相同*

```python
>>>  arr = np.array([1, 2, 3, 4, 5])
>>>  arr.dtype
dtype('int64')
>>>  float_arr = arr.astype(np.float64)
>>>  float_arr.dtype
dtype('float64')
```

* 浮点数转换为整数时，小数部分将会被截取删除
* 如果字符串数组表示的全是数字，也可以用astype将其转换为数值形式
* 在astype方法转换时，参数可以简写，例如np.float64简写成float(NumPy会将Python类型映射到等价的dtype上)
* 使用numpy.string_类型时，因为NumPy的字符串数据大小是固定的，发生截取时，不会发出警告

*数组的dtype的另外一个属性*

```python
>>>  int_array = np.arange(10)
>>> calibers = np.array([.22, .270, .357, .380, .44, .50], dtype = np.float64)
>>> int_array.astype(calibers.dtype)
array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])
```

*可以用简洁的类型代码表示dtype*

```python
empty_uint32 = np.empty(8, dtype = 'u4')
```

---

#### NumPy运算

数组可以使你不用编写循环即可对数据执行批量运算(*NumPy用户称其为矢量化*)

1. 大小相等的数组之间的任何运算都会将运算应用到元素级

```python
>>>  arr = np.array([[1., 2., 3.], [4., 5., 6.]])
>>>  arr * arr
array([[1., 4., 9.], [16., 25., 36.]])
>>>  arr - arr
array([[0., 0., 0.], [0., 0., 0.]])
```

2. 数组与标量之间的运算也会将标量传播到各个元素

```python
>>>  arr = np.array([[1., 2., 3.], [4., 5., 6.]])
>>>  1 / arr
array([[1., 0.5, 0.3333], [0.25, 0.2, 0.1667]])
```
```python
>>>  arr = np.array([[1., 2., 3.], [4., 5., 6.]])
>>>  arr ** 0.5
array([[1.    , 1.4142, 1.7321], [2.    , 2.2361, 2.4495]])
```

3. 大小相同的数组之间的比较会生成布尔值数组

```python
>>>  arr = np.array([[1., 2., 3.], [4., 5., 6.]])
>>>  arr2 = np.array([[0., 4., 1.], [7., 2., 12.]])
>>>  arr2 > arr
array([[False, True, False], [True, False, True]], dtype = bool)
```

4. 不同大小的数组之间的运算叫做广播

---

##### 基本索引

*和列表不同的是，对ndarray数组切片的操作会直接修改到源ndarray数组上*

1. 一维ndarray数组很简单，和Python列表的功能差不多

```python
>>>  arr = np.arange(10)
>>>  arr[5]
5
>>>  arr[5:8]
array([5, 6, 7])
>>>  arr[5:8] = 12
>>>  arr
array([0, 1, 2, 3, 4, 12, 12, 12, 8, 9])
```

```python
#  对ndarray数组切片的操作会直接修改到源ndarray数组上
>>>  arr = np.arange(10)
>>>  arr_slice = arr[5:8]
>>>  arr_slice[1] = 12345
>>> arr
array([    0,     1,     2,     3,     4,     5, 12345,     7,     8,     9])
#  切片[:]会给数组中的所有值赋值
>>>  arr_slice[:] = 64
>>>  arr
array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])
```

*如果要得到ndarray切片的副本，需要明确进行复制操作，例如：`arr[5:8].copy()`*

2. 二维ndarray数组中，各索引位置上的元素不再是标量而是一维数组

```python
>>>  arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
>>>  arr2d[2]
array([7, 8, 9])
#  可以对元素进行递归访问，也可以传入一个以逗号隔开的索引列表来选取单个元素
>>>  arr2d[2][3]
3
>>>  arr2d[0, 2]
3
```

3. 多维ndarray数组中，如果省略了后面的索引，则返回对象是一个维度低一点的ndarray

```python
>>>  arr3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
#  arr3d[0]是一个2x3数组
>>>  arr3d[0]
array([[1, 2, 3], [4, 5, 6]])
#  标量值和数组都可以被赋值给arr3d[0]
>>>  old_values = arr3d[0].copy()
>>>  arr3d[0] = 42
>>>  arr3d
array([[[42, 42, 42], [42, 42, 42]], [[7, 8, 9], [10, 11, 12]]])
>>>  arr3d[0] = old_values
>>>  arr3d
array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
>>>  arr3d[1, 0]
array([7, 8, 9])
#  上述所有这些选取数组子集的例子中，返回的数组都是视图，任何修改都会直接修改到源数组上
```

---

##### 基本切片

1. 一维ndarray数组的切片语法跟Python列表这样的一维对象差不多

```python
>>>  arr = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>>  arr[1:6]
array([1, 2, 3, 4, 5])
```

2. 二维ndarray数组切片

```python
>>>  arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
>>>  arr2d[:2]
array([[1, 2, 3], [4, 5, 6]])
#  可以像索引那样一次传入多个切片
>>>  arr2d[:2, 1:]
array([[2, 3], [5, 6]])
#  上述切片只能得到相同维度的数组视图，通过混合索引和切片，可以得到低维度的切片
>>>  arr2d[1, :2]
array([4, 5])
>>>  arr2d[:2, 2]
array([3, 6])
# 只有冒号表示选取整个轴，可以像下述操作只对高维轴进行切片
>>>  arr2d[:, :1]
array([[1],[4],[7]])
#  对切片表达式的赋值操作也会被扩散到整个选取
>>>  arr2d[:2, 1:] = 0
>>>  arr2d
array([[1, 0, 0], [4, 0, 0], [7, 8, 9]])
```

3. 高维ndarray数组切片
参照二维自行拓展

---

##### 布尔型索引

* 通过布尔型索引选取数组中的数据，总是创建数据的副本，即使返回一模一样的数组也是如此
* python关键字and和or在布尔型数组中无效。要使用&和|

```python
>>>  names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
#  使用numpy.random中的randon函数生成一些正太分布的随机数据
>>>  date = np.random.randn(7, 4)
>>>  names
array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'], dtype = '<U4')
>>>  data
array([[0.0929, 0.2817, 0.769, 1.2464], [1.0072, -1.2962, 0.275, 0.2289], [1.3529, 0.8864, -2.0016, -0.3718], [1.669, -0.4386, -0.5397, 0.477], [3.2489, -1.0212, -0.5771, 0.1241], [0.3026, 0.5238, 0.0009, 1.3438], [-0.7135, -0.8312, -2.3702, -1.8608]])
#  假设每个名字都对应data数组中的一行
>>>  names == 'Bob'
array([True, False, False, True, False, False, False,], dtype = bppl)
#  这个布尔型数组可用于数组索引
>>>  data[names == 'Bob']
array([[0.0929, 0.2817, 0.769, 1.2464], [1.669, -0.4386, -0.5397, 0.477]])
#  布尔型数组的长度必须跟被索引的轴长度一致
#  可以将布尔型数组跟切片,整数(或整数序列)混合使用(整数数组索引即花式索引)
>>>  data[names == 'Bob', 2:]
array([[0.769, 1.2464], [-0.5397, 0.477]])
#  要选取除'BOb'以外的其他值，既可以使用不等于符号(!=)，也可以通过~对条件进行否定
>>>  names != 'Bob'
array([False, True, True, False, True, True, True], dtype = bool)
>>>  data[~(name == 'Bob')]
array([[1.0072, -1.2962, 0.275, 0.2289], [1.3529, 0.8864, -2.0016, -0.3718], [3.2489, -1.0212, -0.5771, 0.1241], [0.3026, 0.5238, 0.0009, 1.3438], [-0.7135, -0.8312, -2.3702, -1.8608]])
#  ~操作符用来反转条件
>>>  cond = names == 'Bob'
>>>  data[~cond]
array([[1.0072, -1.2962, 0.275, 0.2289], [1.3529, 0.8864, -2.0016, -0.3718], [3.2489, -1.0212, -0.5771, 0.1241], [0.3026, 0.5238, 0.0009, 1.3438], [-0.7135, -0.8312, -2.3702, -1.8608]])
#  可以组合应用多个布尔条件，使用&(和),|(或)之类的布尔运算符
>>>  mask = (names == 'Bob') | (names == 'Will')
>>>  mask
array([True, False, True, True, True, False, False], dtype = bool)
>>>  data[data < 0] = 0
>>>  data
array([[0.0929, 0.2817, 0.769, 1.2464], [1.0072, 0.    , 0.275, 0.2289], [1.3529, 0.8864, 0.    , 0.    ], [1.669, 0.    , 0.    , 0.477], [3.2489, 0.    , 0.    , 0.1241], [0.3026, 0.5238, 0.0009, 1.3438], [0.    , 0.    , 0.    , 0.    ]])
>>>  data[names != 'Joe'] = 7
>>>  data
array([[7.    , 7.    , 7.    , 7.    ], [1.0072, -1.2962, 0.275, 0.2289], [7.    , 7.    , 7.    , 7.    ], [7.    , 7.    , 7.    , 7.    ], [7.    , 7.    , 7.    , 7.    ], [0.3026, 0.5238, 0.0009, 1.3438], [0.    , 0.    , 0.    , 0.    ]])
```

---

##### 花式索引

花式索引(Fancy indexing)是一个NumPy术语，指利用整数数组进行索引

```python
#  假设有一个8x4数组
>>>  arr = np.empty((8,4))
>>>  for i in range(8):
    arr[i] = 1
>>>  arr
array([[0., 0., 0., 0.], [1., 1., 1., 1.], [2., 2., 2. ,2.], [3., 3., 3., 3.], [4., 4., 4., 4.], [5., 5., 5., 5.], [6., 6., 6., 6.], [7., 7., 7., 7.]])
>>>  arr[[4, 3, 0, 6]]
array([[4., 4., 4., 4.], [3., 3., 3., 3.], [0., 0., 0., 0.], [6., 6., 6., 6.]])
#  使用负数索引将会从末尾开始选取
>>>  arr[[-3, -5, -7]]
array([[5., 5., 5., 5.], [3., 3., 3., 3.], [1., 1., 1., 1.]])
#  可以一次传入多个索引数组，它返的是一个一维数组，其中的元素对应各个索引元组(无论数组是多少维，花式索引总是一维)
>>>  arr = np.arange(32).reshape((8, 4))
>>>  arr
array([[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23], [24, 25, 26, 27], [28, 29, 30, 31]])
>>>  arr[[1, 5, 7, 2], [0, 3, 1, 2]]
array([4, 23, 29, 10])
#  花式索引跟切片不一样，花式索引总是将数据复制到新数组中
#  可用以下办法得到不同的用户预测的索引
>>>  arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]]
array([[4, 7, 5, 6], [20, 23, 21, 22], [28, 31, 29, 30], [8, 11, 9, 10]])
```

---

##### 数组的转置和轴对换

转置是重塑的一种特殊形式，它返回的是源数据的视图(不会进行任何复制操作)。数组不仅有transpose方法，还有一个特殊的T属性

二维：

```python
>>>  arr = np.arange(15).reshape((3, 5))
>>>  arr
array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14]])
>>>  arr.T
array([[0, 5, 10], [1, 6, 11], [2, 7, 12], [3, 8, 13], [4, 9, 14]])
#  在进行矩阵计算时，经常需要用到.T，比如计算矩阵内积
>>>  arr = np.random.randn(6, 3)
>>>  np.dot(arr.T , arr)
```

高维：

对于高维数组，transpose需要得到一个由轴编号组成的元组才能对这些轴进行转置

```python
>>>  arr = np.arange(10).reshape((2,2,4))
>>>  arr
array([[[0, 1, 2, 3], [4, 5, 6, 7]], [[8, 9, 10, 11], [12, 13, 14, 15]]])
>>>  arr.transpose((1, 0, 2))
array([[[0, 1, 2, 3], [8, 9, 10, 11]], [[4, 5, 6, 7], [12, 13, 14, 15]]])
#  此处第一个轴被换成了第二个，第二个轴被换成了第一个，最后一个轴不变
#  简单的转置可以使用.T，即轴对换。ndarray还有一个swapaxes方法，它需要接受一对轴编号
>>>  arr
array([[[0, 1, 2, 3], [4, 5, 6, 7]], [[8, 9, 10, 11], [12, 13, 14, 15]]])
>>>  arr.swapaxes(1, 2)
array([[[0, 4], [1, 5], [2, 6], [3, 7]], [[8, 12], [9, 13], [10, 14], [11, 15]]])
#  swapaxes也是返回源数据的视图(不会进行任何复制操作)
```

---

### NumPy通用函数

NumPy通用函数(ufunc)是一种对ndarray中的数据执行元素级运算的函数。

*可以将通用函数看作简单函数(接受一个或多个标量值，并产生一个或多个标量值)的矢量化包装器*

*np.ufunc*

*表1：常见一元ufunc*

函数 | 说明
:-: | :-:
abs, fabs | 计算整数,浮点数或复数的绝对值。对于非复数值，可以使用更快的fabs
sqrt | 计算各元素的平方根。相当于arr ** 0.5
square | 计算各元素的平方。相当于arr ** 2
exp | 计算各元素的指数e^x
log, log10, log2, log1p | 分别为自然对数(底数为e)，底数为10的log，底数为2的log，log(1+x)
sigin | 计算各元素的正负号：1(正数)，0(零)，-1(负数)
ceil | 计算各元素的ceiling值，即大于等于该值的最小整数
floor | 计算个元素的floor值，即小于等于该值的最大整数
rint | 将各元素值四舍五入到最接近的整数，保留dtype
modf | 将数组的小数和整数部分以两个独立数组的形式返回
isnan | 返回一个表示“哪些值是NaN”的布尔型数组
isfinite, isinf | 分别返回一个表示“哪些元素是有穷的(非inf，非NaN)”或“哪些元素是无穷的”的布尔型数组
cos, cosh, sin, sinh, tan, tanh | 普通型和双曲线型三角函数
arccos, arccosh, arcsin, arcsinh, arctan, arctanh | 反三角函数
logical_not | 计算各元素not x的真值，相当于-arr

*表2：常见二元ufunc*

函数 | 说明
:-: | :-:
add | 将数组中对应元素相加
subtract | 从第一个数组中减去第二个数组中的元素
multiply | 数组元素相乘
divide, floor_divide | 除法或向下圆整除法(舍弃余数)
power | 对第一个数组中的元素A，根据第二个数组中的相应元素B，计算A^B
maximum, fmax | 元素级的最大值计算。fmax将忽略NaN
minimum, fmin | 元素级的最小值计算。fmin将忽略MaN
mod | 元素级的求模计算(除法的余数)
copysign | 将第二个数组中的值的符号复制给第一个数组中的值
greater, greater_equal, less, less_equal, equal, not_equal | 执行元素级的比较运算，最终产生布尔型数组。相当于中缀运算符>, >=, <, <=, ==, !=
logical_aand, logical_or, logical_xor | 执行元素级的真值逻辑运算。相当于中缀运算符&, |, ^

---

### 利用NumPy数组进行数据处理

NumPy数组使你可以将许多种数据处理任务表述为简洁的数组表达式(否则需要编写循环)。

*用数组表达式代替循环的做法，通常被称为矢量化。矢量化数组运算要比等价的纯Python方式快上一两个数量级*

例如：

```python
>>>  points = np.arange(-5, 5, 0.01)
>>>  xs, ys = np.meshgrid(points, points)
>>>  z = np.sqrt(xs ** 2 + ys ** 2)
```

---

#### 将条件逻辑表述为数组运算

numpy.where函数是三元表达式x if condition else y的矢量化版本

`np.where(a, b, c)` *参数b,c可以不是数组，可以为标量值*

```python
#  假设有一个由随机数据组成的矩阵，把其中正值替换为2,所有负值替换为-2
>>>  arr = np.random.randn(4, 4)
>>>  np.where(arr > 0, 2, -2)
#  使用np,where可以将标量和数组结合起来，例如用常数2替换arr中所有正值
>>>  np.where(arr > 0, 2, arr)
#  传给where的数组大小可以不相等，甚至可以是标量
```

---

#### 数学和统计方法

可以通过数组上的一组数学函数对整个数组或某个轴向的数据进行统计计算

*既可当作数组的实例方法调用，也可以当作顶级NumPy函数使用*
* mean和sum这类的函数可以接受一个axis选项参数(不用该参数即对全部元素进行运算)，用于计算该轴向上的统计值，最终结果是一个少一维的数组
* cumsum和sumprod之类的方法则不聚合，而是产生一个由中间结果组成的数组

```python
>>>  arr = np.array([0, 1, 2, 3, 4, 5, 6, 7])
>>>  arr.cumsum()
array([0, 1, 3, 6, 10, 15, 21, 28])
#  在多维数组中，累加函数返回的是同样大小的数组，但是会根据每个低维的切片沿标记轴计算部分聚类
```

*表：基本数组统计方法*

方法 | 说明
:-: | :-:
sum | 对数组中全部或某轴向的元素求和。零长度的数组的sum为0
mean | 算数平均数。零长度的数组的mean为NaN
std, var | 分别为标准差和方差，自由度可调(默认为n)
min, max | 最大值和最小值
argmin, argmax | 分别为最大和最小元素的索引
cumsum | 所有元素的累计和
sumprod | 所有元素的累计积

---

#### 用于布尔型数组的方法

* sum方法经常用来对布尔型数组中的True值计数

```python
>>>  arr = np.random.randn(100)
>>>  (arr > 0).sum()
42
```

* any方法用于测试数组中是否存在一个或多个True
* all方法检查数组中所有值是否都是True
* any和all方法也可用于非布尔型数组，所有非零元素都会被当作True

```python
>>>  bools = np.array([False, False, True, False])
>>>  bools.any()
True
>>>  bools.all()
False
```

---

#### 排序

* NumPy数组可以通过sort方法就地排序

```python
arr = np.random.randn(6)
arr.sort()
```

* 多维数组可以在任何一个轴上进行排序，只需将轴编号传给sort即可

```python
arr = np.random.randn(5, 3)
arr.sort(1)
```

* 顶级方法np.sort返回的是数组的已排序副本，而就地排序则会修改数组本身

*计算数组分位数最简单的方法就是对其排序，然后选取特定位置的值*

---

#### 唯一化以及其它的集合逻辑

NumPy提供了一些针对一维ndarray的基本集合元算

*表：数组的集合运算*

方法 | 说明
:-: | :-:
unique(x) | 计算x中的唯一元素，并返回有序结果
intersect1d(x, y) | 计算x和y中的公共元素，并返回有序结果
union1d(x, y) | 计算x和y的并集，并返回有序结果
in1d(x, y) | 得到一个表示“x的元素是否包含于y”的布尔型数组
setdiff1d(x, y) | 集合的差，即元素在x中且不在y中
setxor1d(x, y) | 集合的对称差，即存在于一个数组中但不同时存在于两个数组中的元素

---

### 用于NumPy数组的文件输入输出

NumPy能够读写磁盘上的文本数据或二进制数据。(此处只讨论NumPy的内置二进制格式)

*建议用pandas或其他工具加载文本或表格数据所以本文不多做介绍NumPy读取磁盘的文本数据*

np.save和np.load是读取磁盘NumPy数组数据的两个重要函数

```python
#  默认情况下，NumPy数组是以未压缩的原始二进制格式保存在拓展名为.npy的文件中
>>>  arr = np.arange(10)
>>>  np.save('some_array', arr)
#  如果文件路径末尾没有拓展名.npy，则会自动加上该拓展名。
#  然后可通过np.load读取磁盘上的数组
>>>  np.load('some_array.npy')
array([0, 1, 2, 3, 4, , 6, 7, 8, 9])
#  通过np.savez可以将多个数组保存到一个未压缩文件中，将数组以关键字参数的形式传入即可
>>>  np.savez('array_archive.npz', a = arr, b = arr)
#  加载.npz文件时，会得到一个类似字典的对象，该对象会对各个数组进行延迟加载
>>>  arch = np.load('array_archive.npz')
>>>  aarch['b']
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
#  如果要将数据压缩，可使用numpy.savez_compressed
>>>  np.savez_compressed('arrays_compressed.npz', a = arr, b = arr)
```

---

### 线性代数

线性代数(如矩阵乘法,矩阵分解,行列式以及其他方阵数学等)是任何数组库的重要组成部分

NumPy提供了一个用于矩阵乘法的dot函数(既是一个数组方法也是numpy命名空间中的一个函数)

```python
>>>  x = np.array([[1., 2., 3.], [4., 5., 6.]])
>>>  y = np.array([[6., 23.], [-1, 7], [8, 9]])
>>>  x.dot(y)
array([[28., 64.], [67., 181.]])
>>>  np.dot(x, y)
array([[28., 64.], [67., 181.]])
#  x.dot(y)等价于np.dot(x, y)
```

numpy.linalg中有一组标准的矩阵分解运算以及诸如求逆和行列式之类的东西

```python
from numpy.linalg import inv, qr
#  可以如上导入linalg中的inv, qr或其他函数
```

*表：常用的numpy.linalg函数*

函数 | 说明
:-: | :-:
diag | 以一维数组的形式返回方阵的对角线(或非对角线)元素，或将一维数组转换为方阵(非对角线元素为0)
dot | 矩阵乘法
trace | 计算对角线元素的和
det | 计算矩阵行列式
eig | 计算方阵的本征值和本征向量
inv | 计算方阵的逆
pinv | 计算矩阵的Moore-Penrose伪逆
qr | 计算QR分解
svd | 计算奇异值分解
solve | 解线性方程组Ax = b, 其中A为一个方阵
lstsq | 计算AX = b的最小二乘解

---

*表：常用的numpy.linalg函数*

### 伪随机数生成

numpy.random模块中对Python内置的random进行了补充，增加了一些用于高效生成多种概率分布的样本值的函数。

1. 伪随机数都是通过基于随机数生成器种子，在确定性的条件下生成的

```python
#  可以用NumPy的np.random.seed更改随机数生成种子
>>>  np.random.seed(1234)
```

2. numpy.random的数据生成函数使用了全局的随机种子。要避免全局状态，可以使用numpy.random.RandomState，创建一个与其它隔离的随机数生成器

```python
>>>  rng = np.random.RandomState(1234)
>>>  rng.randn(10)
```

*表：部分numpy.random函数*

函数 | 说明
:-: | :-:
seed | 确定随机数生成器的种子
permutation | 返回一个序列的随机排列或返回一个随机排列的范围
shuffle | 对一个序列就地随机排列
rand | 产生均值分布的样本值
randint | 从给定的上下限范围内随机选取整数
randn | 产生正态分布(平均值为0,标准差为1)的样本值，类似于MATLAB接口
binomial | 产生二项分布的样本值
normal | 产生正态(高斯)分布的样本值
beta | 产生Beta分布的样本值
chisquare | 产生卡方分布的样本值
gamma | 产生Gamma分布的样本值
uniform | 产生在[0, 1)中均匀分布的样本值

---